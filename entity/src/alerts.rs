//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.1
//-------------------------------------------------------------------------------------------------
// Alert
//-------------------------------------------------------------------------------------------------

use {
    chrono::Duration,
    sea_orm::entity::prelude::*,
    std::{fmt, sync::LazyLock},
};

// Old diesel schema for reference:
// table! {
//     alerts (id) {
//         id -> Int4,
//         guid -> Text,
//         title -> Text,
//         #[sql_name = "type"]
//         kind -> Text,
//         startdate -> Timestamptz,
//         expirydate -> Nullable<Timestamptz>,
//         faction -> Nullable<Text>,
//         flavor -> Nullable<Text>,
//     }
// }

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "alerts")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    #[sea_orm(column_type = "Text", unique)]
    pub guid: String,
    #[sea_orm(column_type = "Text")]
    pub title: String,
    #[sea_orm(column_type = "Text", column_name = "type")]
    pub kind: String,
    #[sea_orm(column_name = "startdate")]
    pub start_date: ChronoDateTimeWithTimeZone,
    #[sea_orm(column_name = "expirydate")]
    pub expiry_date: Option<ChronoDateTimeWithTimeZone>,
    #[sea_orm(column_type = "Text", nullable)]
    pub faction: Option<String>,
    #[sea_orm(column_type = "Text", nullable)]
    pub flavor: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

impl fmt::Display for Model {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{} {} {}",
            self.type_icon(),
            self.reward_icon(),
            self.title
        )
    }
}

impl Model {
    pub fn is_important(&self) -> bool {
        self.is_forma()
            || self.is_nitain()
            || self.is_orokin_reactor()
            || self
                .expiry_date
                .map(|exp| exp - self.start_date >= Duration::minutes(90))
                .unwrap_or(false)
    }

    pub fn type_icon(&self) -> String {
        match self.kind.as_str() {
            "Alert" => "âœŠ".into(),
            "Invasion" => "ðŸ›".into(),
            "Outbreak" => "â›“".into(),
            _ => format!("â‰ï¸ {}", self.kind),
        }
    }

    pub fn reward_icon(&self) -> String {
        if self.is_forma() {
            "âš–"
        } else if self.is_nitain() {
            "âœ¨"
        } else if self.is_orokin_reactor() {
            "ðŸ®"
        } else if self.is_endo() {
            "ðŸ”®"
        } else if self.is_blueprint() {
            "ðŸ—¿"
        } else if self.is_resource() {
            "ðŸ”‹"
        } else if self.is_mod() {
            "âš™"
        } else if self.is_aura() {
            "â„ï¸"
        } else if self.is_credits() {
            "ðŸ’°"
        } else {
            ""
        }
        .into()
    }

    pub fn is_blueprint(&self) -> bool {
        self.title.contains("(Blueprint)")
    }

    pub fn is_resource(&self) -> bool {
        self.title.contains("(Resource)")
    }

    pub fn is_mod(&self) -> bool {
        self.title.contains("(Mod)")
    }

    pub fn is_aura(&self) -> bool {
        self.title.contains("(Aura)")
    }

    pub fn is_credits(&self) -> bool {
        static CREDITS: LazyLock<regex::Regex> =
            LazyLock::new(|| regex::Regex::new(r"^\d+cr ").unwrap());
        CREDITS.is_match(&self.title)
    }

    pub fn is_forma(&self) -> bool {
        self.title.contains("Forma")
    }

    pub fn is_nitain(&self) -> bool {
        self.title.contains("Nitain Extract")
    }

    pub fn is_orokin_reactor(&self) -> bool {
        self.title.contains("Orokin Reactor")
    }

    pub fn is_endo(&self) -> bool {
        self.title.contains("ENDO")
    }
}

#[cfg(test)]
mod tests {
    use {
        crate::establish_db_connection,
        anyhow::Result,
        dotenv::dotenv,
        sea_orm::{EntityTrait, QuerySelect},
    };

    #[tokio::test]
    #[ignore]
    async fn test_alerts() -> Result<()> {
        dotenv().ok();
        let db = establish_db_connection().await?;

        let results = super::Entity::find().limit(5).all(&db).await?;

        println!("Displaying {} alerts", results.len());
        for alrt in results {
            println!("{}", alrt.title);
        }

        Ok(())
    }
}

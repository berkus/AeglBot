//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.1
//-------------------------------------------------------------------------------------------------
// Guardian
//-------------------------------------------------------------------------------------------------

use {sea_orm::entity::prelude::*, std::fmt};

// Old diesel schema for reference:
// table! {
//     guardians (id) {
//         id -> Int4,
//         telegram_name -> Text,
//         telegram_id -> Int8,
//         psn_name -> Text,
//         email -> Nullable<Text>,
//         psn_clan -> Nullable<Text>,
//         created_at -> Timestamptz,
//         updated_at -> Timestamptz,
//         deleted_at -> Nullable<Timestamptz>,
//         tokens -> Nullable<Jsonb>,
//         pending_activation_code -> Nullable<Text>,
//         is_admin -> Bool,
//         is_superadmin -> Bool,
//     }
// }

#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel)]
#[sea_orm(table_name = "guardians")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    #[sea_orm(column_type = "Text", unique)]
    pub telegram_name: String,
    #[sea_orm(unique)]
    pub telegram_id: i64,
    #[sea_orm(column_type = "Text")]
    pub psn_name: String,
    #[sea_orm(column_type = "Text", nullable)]
    pub email: Option<String>,
    #[sea_orm(column_type = "Text", nullable)]
    pub psn_clan: Option<String>,
    pub created_at: ChronoDateTimeWithTimeZone,
    pub updated_at: ChronoDateTimeWithTimeZone,
    pub deleted_at: Option<ChronoDateTimeWithTimeZone>,
    #[sea_orm(column_type = "JsonBinary", nullable)]
    pub tokens: Option<Json>,
    #[sea_orm(column_type = "Text", nullable)]
    pub pending_activation_code: Option<String>,
    pub is_admin: bool,
    pub is_superadmin: bool,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::plannedactivities::Entity")]
    PlannedActivities,
    #[sea_orm(has_many = "super::plannedactivitymembers::Entity")]
    PlannedActivityMembers,
}

impl Related<super::plannedactivities::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::PlannedActivities.def()
    }
}

impl Related<super::plannedactivitymembers::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::PlannedActivityMembers.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl fmt::Display for Model {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.format_name())
    }
}

impl Model {
    pub fn format_name(&self) -> String {
        format!("{} (t.me/{})", self.psn_name, self.telegram_name)
    }

    pub fn names(&self) -> (String, String) {
        (self.telegram_name.clone(), self.psn_name.clone())
    }
}

#[cfg(test)]
mod tests {
    use {
        crate::establish_db_connection,
        anyhow::Result,
        dotenv::dotenv,
        sea_orm::{EntityTrait, PaginatorTrait},
    };

    #[tokio::test]
    #[ignore]
    async fn test_guardians() -> Result<()> {
        dotenv().ok();
        let db = establish_db_connection().await?;

        let mut results = super::Entity::find().paginate(&db, 10);

        while let Some(guardians) = results.fetch_and_next().await? {
            for guar in guardians {
                println!("{guar}");
            }
        }

        Ok(())
    }
}

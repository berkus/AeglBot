//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.1
//-------------------------------------------------------------------------------------------------
// PlannedActivity
//-------------------------------------------------------------------------------------------------

use {
    crate::{
        guardians,
        plannedactivitymembers::{self, ActivityMemberTemplate},
    },
    chrono::Duration,
    culpa::throws,
    libbot::datetime::{format_start_time, reference_date},
    sea_orm::{entity::prelude::*, QueryOrder},
};

// Old diesel schema for reference:
// table! {
//     plannedactivities (id) {
//         id -> Int4,
//         author_id -> Int4,
//         activity_id -> Int4,
//         details -> Nullable<Text>,
//         start -> Timestamptz,
//     }
// }

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "planned_activities")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub author_id: i32,   // refs Guardians
    pub activity_id: i32, // refs Activities
    #[sea_orm(column_type = "Text", nullable)]
    pub details: Option<String>,
    pub start: ChronoDateTimeWithTimeZone,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::activities::Entity",
        from = "Column::ActivityId",
        to = "super::activities::Column::Id",
        on_update = "Cascade",
        on_delete = "Restrict"
    )]
    Activities,
    #[sea_orm(
        belongs_to = "super::guardians::Entity",
        from = "Column::AuthorId",
        to = "super::guardians::Column::Id",
        on_update = "NoAction",
        on_delete = "NoAction"
    )]
    Guardians,
    #[sea_orm(has_many = "super::plannedactivitymembers::Entity")]
    PlannedActivityMembers,
}

impl Related<super::activities::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Activities.def()
    }
}

impl Related<super::guardians::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Guardians.def()
    }
}

impl Related<super::plannedactivitymembers::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::PlannedActivityMembers.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

// Output information
#[derive(serde::Serialize)]
pub struct PlannedActivityTemplate {
    pub id: i32,
    pub name: String,
    pub details: String,
    pub members: Vec<ActivityMemberTemplate>,
    pub count: usize,
    pub time: String,
    pub fireteam_full: bool,
    pub fireteam_joined: bool,
    pub join_link: String,
    pub leave_link: String,
}

impl Entity {
    pub async fn upcoming_activities(connection: &DatabaseConnection) -> Vec<Model> {
        Self::find()
            .filter(Column::Start.gt(reference_date() - Duration::minutes(60)))
            .all(connection)
            .await
            .unwrap_or_default()
    }

    pub async fn upcoming_activities_alert(connection: &DatabaseConnection) -> Option<Vec<Model>> {
        // log::info!("reminder check at {}", reference_date());

        let reference = reference_date();

        let upcoming_events = Self::find()
            .filter(Column::Start.gt(reference))
            .all(connection)
            .await
            .unwrap_or_default()
            .into_iter()
            .filter(|event| {
                let event_start: chrono::DateTime<chrono::Utc> = event.start.into();
                if event_start > reference {
                    let diff = event_start - reference;
                    matches!(diff.num_minutes(), 60 | 15 | 0)
                } else {
                    false
                }
            })
            .collect::<Vec<_>>();

        if upcoming_events.is_empty() {
            return None;
        }

        Some(upcoming_events)
    }
}

impl Model {
    #[throws(sea_orm::DbErr)]
    pub async fn to_template(
        &self,
        connection: &DatabaseConnection,
        guardian: Option<&guardians::Model>,
    ) -> PlannedActivityTemplate {
        let activity = self.activity(connection).await?.unwrap(); // use Relation

        let members = self.members(connection).await?;
        let mut memvec = Vec::new();
        for x in members {
            memvec.push(x.to_template(connection).await?);
        }
        let members = memvec;

        let count = activity.max_fireteam_size as usize - members.len();

        PlannedActivityTemplate {
            id: self.id,
            name: activity.format_name(),
            details: self.format_details(),
            members,
            count,
            time: format_start_time(self.start.into(), reference_date()),
            fireteam_full: count == 0,
            fireteam_joined: self.find_member(connection, guardian).await?.is_some(),
            join_link: self.join_link(),
            leave_link: self.cancel_link(),
        }
    }

    #[throws(sea_orm::DbErr)]
    pub async fn author(&self, connection: &DatabaseConnection) -> Option<guardians::Model> {
        self.find_related(crate::guardians::Entity)
            .one(connection)
            .await?
    }

    #[throws(sea_orm::DbErr)]
    pub async fn activity(
        &self,
        connection: &DatabaseConnection,
    ) -> Option<crate::activities::Model> {
        self.find_related(crate::activities::Entity)
            .one(connection)
            .await?
    }

    #[throws(sea_orm::DbErr)]
    pub async fn members(
        &self,
        connection: &DatabaseConnection,
    ) -> Vec<super::plannedactivitymembers::Model> {
        self.find_related(crate::plannedactivitymembers::Entity)
            .order_by_asc(crate::plannedactivitymembers::Column::Added)
            .all(connection)
            .await?
    }

    #[throws(sea_orm::DbErr)]
    pub async fn members_count(&self, connection: &DatabaseConnection) -> usize {
        self.find_related(crate::plannedactivitymembers::Entity)
            .order_by_asc(crate::plannedactivitymembers::Column::Added)
            .count(connection)
            .await? as usize
    }

    pub fn join_link(&self) -> String {
        format!("/join{}", self.id)
    }

    pub fn cancel_link(&self) -> String {
        format!("/cancel{}", self.id)
    }

    #[throws(sea_orm::DbErr)]
    pub async fn join_prompt(&self, connection: &DatabaseConnection) -> String {
        if self.is_full(connection).await? {
            "This activity fireteam is full.".into()
        } else {
            let count = self.activity(connection).await?.unwrap().max_fireteam_size as usize
                - self.members_count(connection).await?;
            format!(
                "Enter `{joinLink}` to join this group. Up to {count} more can join.",
                joinLink = self.join_link(),
                count = count
            )
        }
    }

    #[throws(sea_orm::DbErr)]
    pub async fn is_full(&self, connection: &DatabaseConnection) -> bool {
        self.members_count(connection).await?
            >= self.activity(connection).await?.unwrap().max_fireteam_size as usize
    }

    #[throws(sea_orm::DbErr)]
    pub async fn requires_more_members(&self, connection: &DatabaseConnection) -> bool {
        self.members_count(connection).await?
            < self.activity(connection).await?.unwrap().min_fireteam_size as usize
    }

    pub fn format_details(&self) -> String {
        self.details.clone().map(|s| s + "\n").unwrap_or_default()
    }

    #[throws(sea_orm::DbErr)]
    pub async fn members_formatted(&self, connection: &DatabaseConnection, joiner: &str) -> String {
        use futures::future::try_join_all;

        let members = self.members(connection).await?;
        let futures = members.into_iter().map(|guardian| {
            crate::plannedactivitymembers::Model::format_member_name(connection, guardian.user_id)
        });
        let names: Vec<String> = try_join_all(futures).await?;
        names.join(joiner)
    }

    #[throws(sea_orm::DbErr)]
    pub async fn members_formatted_list(&self, connection: &DatabaseConnection) -> String {
        self.members_formatted(connection, ", ").await?
    }

    #[throws(sea_orm::DbErr)]
    pub async fn members_formatted_column(&self, connection: &DatabaseConnection) -> String {
        self.members_formatted(connection, "\n").await?
    }

    // This should be on Entity?
    #[throws(sea_orm::DbErr)]
    pub async fn find_member(
        &self,
        connection: &DatabaseConnection,
        guardian: Option<&guardians::Model>,
    ) -> Option<plannedactivitymembers::Model> {
        if let Some(g) = guardian {
            return plannedactivitymembers::Entity::find()
                .filter(plannedactivitymembers::Column::UserId.eq(g.id))
                .filter(plannedactivitymembers::Column::PlannedActivityId.eq(self.id))
                .one(connection)
                .await?;
        }
        None
    }
}

// #[cfg(test)]
// mod tests {
//     use {
//         crate::establish_db_connection,
//         anyhow::Result,
//         dotenv::dotenv,
//         sea_orm::{EntityTrait, PaginatorTrait},
//     };
//
//     #[tokio::test]
//     #[ignore]
//     async fn test_planned_activities() -> Result<()> {
//         dotenv().ok();
//         let db = establish_db_connection().await;
//
//         // TODO: Fix this test to use SeaORM syntax
//         // let guar = guardians
//         //     .find(1)
//         //     .first::<Guardian>(&connection)
//         //     .expect("Guardian with id 1 not found");
//         // let results = PlannedActivity::belonging_to(&guar)
//         //     .load::<PlannedActivity>(&connection)
//         //     .expect("Error loading activities");
//
//         // println!("Displaying {} planned activities", results.len());
//         // for act in results {
//         //     println!("{}", act.to_string(&connection, Some(&guar)));
//         // }
//
//         Ok(())
//     }
// }
